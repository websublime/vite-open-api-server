/**
 * Router Types
 *
 * What: Type definitions for endpoint registry and routing
 * How: Interfaces for endpoint metadata and registry
 * Why: Provides type safety for route management
 *
 * @module router/types
 */

/**
 * HTTP methods supported by the router
 * Includes all methods defined in OpenAPI specification
 */
export type HttpMethod = 'get' | 'post' | 'put' | 'patch' | 'delete' | 'options' | 'head' | 'trace';

/**
 * Security requirement from OpenAPI spec
 *
 * @remarks
 * **Simplification:** In the OpenAPI spec, a single security requirement object
 * can list multiple schemes (e.g., `{ bearerAuth: [], apiKey: [] }`), meaning
 * ALL listed schemes must be satisfied (AND logic). However,
 * `extractSecurityRequirements` in the registry builder **flattens** compound
 * requirements into individual entries â€” each scheme becomes its own
 * `SecurityRequirement`. As a result, `validateSecurity` treats all entries
 * with OR logic (first matching scheme wins), and true AND-within-OR semantics
 * are not supported.
 *
 * This is a known limitation. Supporting grouped/AND semantics is potential
 * future work (would require a nested structure like `SecurityRequirement[][]`).
 */
export interface SecurityRequirement {
  name: string;
  scopes: string[];
}

/**
 * Registry entry for a single endpoint
 */
export interface EndpointEntry {
  operationId: string;
  method: HttpMethod;
  path: string;
  summary?: string;
  description?: string;
  tags: string[];
  responseSchema?: string;
  hasHandler: boolean;
  hasSeed: boolean;
  security: SecurityRequirement[];
}

/**
 * Composite key for endpoint registry Map
 * Format: "METHOD:path" (e.g., "get:/users/{id}", "post:/users")
 *
 * @example
 * ```typescript
 * // Creating a key
 * const key: EndpointKey = `${method}:${path}`;
 *
 * // Parsing a key
 * const [method, ...pathParts] = key.split(':');
 * const path = pathParts.join(':'); // Handle paths with colons
 * ```
 */
export type EndpointKey = `${HttpMethod}:${string}`;

/**
 * Helper to create an EndpointKey from method and path
 */
export function createEndpointKey(method: HttpMethod, path: string): EndpointKey {
  return `${method}:${path}`;
}

/**
 * Helper to parse an EndpointKey into method and path
 */
export function parseEndpointKey(key: EndpointKey): { method: HttpMethod; path: string } {
  const colonIndex = key.indexOf(':');
  return {
    method: key.slice(0, colonIndex) as HttpMethod,
    path: key.slice(colonIndex + 1),
  };
}

/**
 * Statistics about the endpoint registry
 */
export interface RegistryStats {
  totalEndpoints: number;
  withCustomHandler: number;
  totalSchemas: number;
  withCustomSeed: number;
  autoGenerated: number;
}

/**
 * Registry of all endpoints
 */
export interface EndpointRegistry {
  /** Map of endpoints keyed by "METHOD:path" format */
  endpoints: Map<EndpointKey, EndpointEntry>;
  byTag: Map<string, EndpointEntry[]>;
  byPath: Map<string, EndpointEntry[]>;
  stats: RegistryStats;
}
