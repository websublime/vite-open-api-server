/**
 * Registry Builder
 *
 * What: Builds an EndpointRegistry from an OpenAPI document
 * How: Iterates over all paths/operations and extracts metadata
 * Why: Provides structured access to endpoint information for routing and DevTools
 *
 * @see Task 1.4.2: Build endpoint registry from OpenAPI document
 */

import type { OpenAPIV3_1 } from '@scalar/openapi-types';

import type {
  EndpointEntry,
  EndpointKey,
  EndpointRegistry,
  HttpMethod,
  RegistryStats,
  SecurityRequirement,
} from './types.js';
import { createEndpointKey } from './types.js';

/**
 * HTTP methods supported by OpenAPI
 */
const HTTP_METHODS: readonly HttpMethod[] = [
  'get',
  'post',
  'put',
  'patch',
  'delete',
  'options',
  'head',
  'trace',
] as const;

/**
 * Options for building the registry
 */
export interface RegistryBuilderOptions {
  /**
   * Set of operationIds that have custom handlers
   * Used to populate hasHandler flag on endpoints
   */
  handlerOperationIds?: Set<string>;

  /**
   * Set of schema names that have seed data
   * Used to populate hasSeed flag on endpoints
   */
  seedSchemaNames?: Set<string>;
}

/**
 * Build an EndpointRegistry from an OpenAPI document
 *
 * Iterates over all paths and operations in the document,
 * extracting metadata for each endpoint.
 *
 * @param document - OpenAPI 3.1 document (should be dereferenced)
 * @param options - Optional configuration for handler/seed detection
 * @returns EndpointRegistry with all endpoints indexed
 *
 * @example
 * ```typescript
 * const doc = await processOpenApiDocument('./petstore.yaml');
 * const registry = buildRegistry(doc, {
 *   handlerOperationIds: new Set(['getPetById', 'createPet']),
 *   seedSchemaNames: new Set(['Pet', 'Category']),
 * });
 *
 * // Access endpoints by key
 * const endpoint = registry.endpoints.get('get:/pet/{petId}');
 *
 * // Get all endpoints for a tag
 * const petEndpoints = registry.byTag.get('pet');
 * ```
 */
export function buildRegistry(
  document: OpenAPIV3_1.Document,
  options: RegistryBuilderOptions = {},
): EndpointRegistry {
  const { handlerOperationIds = new Set(), seedSchemaNames = new Set() } = options;

  const endpoints = new Map<EndpointKey, EndpointEntry>();
  const byTag = new Map<string, EndpointEntry[]>();
  const byPath = new Map<string, EndpointEntry[]>();
  const schemaNames = new Set<string>();

  const paths = document.paths ?? {};

  for (const [path, pathItem] of Object.entries(paths)) {
    if (!pathItem) continue;

    for (const method of HTTP_METHODS) {
      const operation = pathItem[method] as OpenAPIV3_1.OperationObject | undefined;
      if (!operation) continue;

      // Build endpoint entry from operation
      const entry = buildEndpointEntry(
        method,
        path,
        operation,
        document,
        handlerOperationIds,
        seedSchemaNames,
      );

      // Track schema names
      if (entry.responseSchema) {
        schemaNames.add(entry.responseSchema);
      }

      // Add to main endpoints map
      const key = createEndpointKey(method, path);
      endpoints.set(key, entry);

      // Index by tag
      indexByTag(byTag, entry);

      // Index by path
      indexByPath(byPath, path, entry);
    }
  }

  // Calculate stats
  const stats: RegistryStats = {
    totalEndpoints: endpoints.size,
    withCustomHandler: Array.from(endpoints.values()).filter((e) => e.hasHandler).length,
    totalSchemas: schemaNames.size,
    withCustomSeed: Array.from(endpoints.values()).filter((e) => e.hasSeed).length,
    autoGenerated: Array.from(endpoints.values()).filter((e) => !e.hasHandler && !e.hasSeed).length,
  };

  return {
    endpoints,
    byTag,
    byPath,
    stats,
  };
}

/**
 * Build an EndpointEntry from an OpenAPI operation
 */
function buildEndpointEntry(
  method: HttpMethod,
  path: string,
  operation: OpenAPIV3_1.OperationObject,
  document: OpenAPIV3_1.Document,
  handlerOperationIds: Set<string>,
  seedSchemaNames: Set<string>,
): EndpointEntry {
  // Generate operationId if not provided
  const operationId = operation.operationId ?? generateOperationId(method, path);

  // Extract response schema name (from 200/201/default response)
  const responseSchema = extractResponseSchemaName(operation);

  // Check if this endpoint has a custom handler
  const hasHandler = handlerOperationIds.has(operationId);

  // Check if the response schema has seed data
  const hasSeed = responseSchema ? seedSchemaNames.has(responseSchema) : false;

  // Extract security requirements
  const security = extractSecurityRequirements(operation, document);

  // Extract tags (default to 'default' if none)
  const tags = operation.tags && operation.tags.length > 0 ? [...operation.tags] : ['default'];

  return {
    operationId,
    method,
    path,
    summary: operation.summary,
    description: operation.description,
    tags,
    responseSchema,
    hasHandler,
    hasSeed,
    security,
  };
}

/**
 * Index an endpoint by its tags
 */
function indexByTag(byTag: Map<string, EndpointEntry[]>, entry: EndpointEntry): void {
  for (const tag of entry.tags) {
    const tagEntries = byTag.get(tag) ?? [];
    tagEntries.push(entry);
    byTag.set(tag, tagEntries);
  }
}

/**
 * Index an endpoint by its path
 */
function indexByPath(
  byPath: Map<string, EndpointEntry[]>,
  path: string,
  entry: EndpointEntry,
): void {
  const pathEntries = byPath.get(path) ?? [];
  pathEntries.push(entry);
  byPath.set(path, pathEntries);
}

/**
 * Generate an operationId from method and path
 *
 * Converts path like /pet/{petId}/uploadImage to getPetPetIdUploadImage
 *
 * @param method - HTTP method
 * @param path - OpenAPI path
 * @returns Generated operationId
 */
function generateOperationId(method: HttpMethod, path: string): string {
  // Remove leading slash and split by /
  const parts = path.replace(/^\//, '').split('/');

  // Convert each part: {petId} -> PetId, pet -> Pet
  const pathParts = parts.map((part) => {
    // Remove braces from path parameters
    const cleaned = part.replace(/[{}]/g, '');
    // Capitalize first letter
    return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
  });

  // Combine method + path parts
  return method + pathParts.join('');
}

/**
 * Extract the response schema name from an operation
 *
 * Looks for the schema in 200, 201, or default response.
 * For array responses, returns the item schema name.
 *
 * @param operation - OpenAPI operation object
 * @returns Schema name or undefined
 */
function extractResponseSchemaName(operation: OpenAPIV3_1.OperationObject): string | undefined {
  const responses = operation.responses;
  if (!responses) return undefined;

  // Check in priority order: 200, 201, default
  const response =
    (responses['200'] as OpenAPIV3_1.ResponseObject) ??
    (responses['201'] as OpenAPIV3_1.ResponseObject) ??
    (responses.default as OpenAPIV3_1.ResponseObject);

  if (!response) return undefined;

  // Get content from response
  const content = response.content;
  if (!content) return undefined;

  // Look for JSON content type
  const jsonContent = content['application/json'] ?? content['*/*'];
  if (!jsonContent) return undefined;

  const schema = jsonContent.schema as OpenAPIV3_1.SchemaObject | undefined;
  if (!schema) return undefined;

  return extractSchemaName(schema);
}

/**
 * Extract schema name from a schema object
 *
 * Handles direct schemas, arrays, and $ref (though document should be dereferenced)
 *
 * @param schema - OpenAPI schema object
 * @returns Schema name or undefined
 */
function extractSchemaName(schema: OpenAPIV3_1.SchemaObject): string | undefined {
  // Check for x-schema-id (injected by processor before dereferencing)
  if ('x-schema-id' in schema && typeof schema['x-schema-id'] === 'string') {
    return schema['x-schema-id'];
  }

  // If it's an array, get the items schema
  if (schema.type === 'array' && schema.items) {
    const itemsSchema = schema.items as OpenAPIV3_1.SchemaObject;
    return extractSchemaName(itemsSchema);
  }

  // Fallback: check title property
  if (schema.title) {
    return schema.title;
  }

  return undefined;
}

/**
 * Extract security requirements from an operation
 *
 * Uses operation-level security if defined, falls back to document-level security.
 *
 * @param operation - OpenAPI operation object
 * @param document - OpenAPI document (for document-level security)
 * @returns Array of security requirements
 */
function extractSecurityRequirements(
  operation: OpenAPIV3_1.OperationObject,
  document: OpenAPIV3_1.Document,
): SecurityRequirement[] {
  // Operation-level security takes precedence (even if empty array - means no auth)
  const securityRequirements = operation.security ?? document.security;

  if (!securityRequirements || securityRequirements.length === 0) {
    return [];
  }

  const requirements: SecurityRequirement[] = [];

  for (const requirement of securityRequirements) {
    // Each requirement is an object like { api_key: [], petstore_auth: ['read:pets'] }
    for (const [name, scopes] of Object.entries(requirement)) {
      requirements.push({
        name,
        scopes: (scopes as string[]) ?? [],
      });
    }
  }

  return requirements;
}

/**
 * Update handler status in an existing registry
 *
 * Useful when handlers are hot-reloaded and the registry needs to be updated.
 *
 * @param registry - Existing endpoint registry
 * @param handlerOperationIds - New set of handler operation IDs
 * @returns Updated registry (mutates in place for efficiency)
 */
export function updateRegistryHandlers(
  registry: EndpointRegistry,
  handlerOperationIds: Set<string>,
): EndpointRegistry {
  let withCustomHandler = 0;

  for (const endpoint of registry.endpoints.values()) {
    endpoint.hasHandler = handlerOperationIds.has(endpoint.operationId);
    if (endpoint.hasHandler) {
      withCustomHandler++;
    }
  }

  registry.stats.withCustomHandler = withCustomHandler;
  registry.stats.autoGenerated = registry.stats.totalEndpoints - withCustomHandler;

  return registry;
}

/**
 * Update seed status in an existing registry
 *
 * Useful when seeds are hot-reloaded and the registry needs to be updated.
 *
 * @param registry - Existing endpoint registry
 * @param seedSchemaNames - New set of schema names with seed data
 * @returns Updated registry (mutates in place for efficiency)
 */
export function updateRegistrySeeds(
  registry: EndpointRegistry,
  seedSchemaNames: Set<string>,
): EndpointRegistry {
  let withCustomSeed = 0;

  for (const endpoint of registry.endpoints.values()) {
    endpoint.hasSeed = endpoint.responseSchema
      ? seedSchemaNames.has(endpoint.responseSchema)
      : false;
    if (endpoint.hasSeed) {
      withCustomSeed++;
    }
  }

  registry.stats.withCustomSeed = withCustomSeed;

  return registry;
}
