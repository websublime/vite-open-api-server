/**
 * Registry Store
 *
 * What: Pinia store for managing endpoint registry data
 * How: Fetches and caches endpoint data from the server via WebSocket
 * Why: Provides reactive access to endpoint data for the Routes Page
 *
 * @module stores/registry
 */

import { defineStore } from 'pinia';
import { computed, ref } from 'vue';

/**
 * HTTP method type
 */
export type HttpMethod = 'get' | 'post' | 'put' | 'patch' | 'delete' | 'options' | 'head' | 'trace';

/**
 * Security requirement from OpenAPI spec
 */
export interface SecurityRequirement {
  name: string;
  scopes: string[];
}

/**
 * Endpoint entry from the server
 */
export interface EndpointEntry {
  key: string;
  operationId: string;
  method: HttpMethod;
  path: string;
  summary?: string;
  description?: string;
  tags: string[];
  responseSchema?: string;
  hasHandler: boolean;
  hasSeed: boolean;
  security: SecurityRequirement[];
}

/**
 * Registry statistics
 */
export interface RegistryStats {
  totalEndpoints: number;
  withCustomHandler: number;
  totalSchemas: number;
  withCustomSeed: number;
  autoGenerated: number;
}

/**
 * Registry data from server
 */
export interface RegistryData {
  endpoints: EndpointEntry[];
  stats: RegistryStats;
}

/**
 * Grouped endpoints by tag
 */
export interface EndpointGroup {
  tag: string;
  endpoints: EndpointEntry[];
  isExpanded: boolean;
}

/**
 * Filter options for endpoints
 */
export interface EndpointFilter {
  methods: HttpMethod[];
  hasHandler: boolean | null;
  hasSeed: boolean | null;
  tags: string[];
}



/**
 * Registry store for endpoint data management
 *
 * Provides:
 * - Endpoint data storage and retrieval
 * - Grouping by tags
 * - Search and filter functionality
 * - Selected endpoint tracking
 */
export const useRegistryStore = defineStore('registry', () => {
  // ==========================================================================
  // State
  // ==========================================================================

  /** All endpoints from the server */
  const endpoints = ref<EndpointEntry[]>([]);

  /** Registry statistics */
  const stats = ref<RegistryStats>({
    totalEndpoints: 0,
    withCustomHandler: 0,
    totalSchemas: 0,
    withCustomSeed: 0,
    autoGenerated: 0,
  });

  /** Loading state */
  const isLoading = ref(false);

  /** Error state */
  const error = ref<string | null>(null);

  /** Search query */
  const searchQuery = ref('');

  /** Active filters */
  const filter = ref<EndpointFilter>({
    methods: [],
    hasHandler: null,
    hasSeed: null,
    tags: [],
  });

  /** Currently selected endpoint key */
  const selectedEndpointKey = ref<string | null>(null);

  /** Expanded tag groups */
  const expandedTags = ref<Set<string>>(new Set());

  // ==========================================================================
  // Getters / Computed
  // ==========================================================================

  /**
   * All unique tags from endpoints
   */
  const allTags = computed(() => {
    const tagSet = new Set<string>();
    for (const endpoint of endpoints.value) {
      for (const tag of endpoint.tags) {
        tagSet.add(tag);
      }
    }
    return Array.from(tagSet).sort();
  });

  /**
   * All unique response schemas
   */
  const allSchemas = computed(() => {
    const schemaSet = new Set<string>();
    for (const endpoint of endpoints.value) {
      if (endpoint.responseSchema) {
        schemaSet.add(endpoint.responseSchema);
      }
    }
    return Array.from(schemaSet).sort();
  });

  /**
   * Filtered endpoints based on search and filters
   */
  const filteredEndpoints = computed(() => {
    let result = endpoints.value;

    // Apply search query
    if (searchQuery.value.trim()) {
      const query = searchQuery.value.toLowerCase().trim();
      result = result.filter((endpoint) => {
        return (
          endpoint.path.toLowerCase().includes(query) ||
          endpoint.operationId.toLowerCase().includes(query) ||
          endpoint.summary?.toLowerCase().includes(query) ||
          endpoint.tags.some((tag) => tag.toLowerCase().includes(query))
        );
      });
    }

    // Apply method filter
    if (filter.value.methods.length > 0) {
      result = result.filter((endpoint) => filter.value.methods.includes(endpoint.method));
    }

    // Apply handler filter
    if (filter.value.hasHandler !== null) {
      result = result.filter((endpoint) => endpoint.hasHandler === filter.value.hasHandler);
    }

    // Apply seed filter
    if (filter.value.hasSeed !== null) {
      result = result.filter((endpoint) => endpoint.hasSeed === filter.value.hasSeed);
    }

    // Apply tag filter
    if (filter.value.tags.length > 0) {
      result = result.filter((endpoint) =>
        endpoint.tags.some((tag) => filter.value.tags.includes(tag)),
      );
    }

    return result;
  });

  /**
   * Endpoints grouped by tag
   *
   * Grouping logic (from PRD):
   * 1. By tags (if they exist in spec)
   * 2. Fallback: By response schema
   * 3. Final fallback: By first path segment
   */
  const groupedEndpoints = computed((): EndpointGroup[] => {
    const groups = new Map<string, EndpointEntry[]>();

    for (const endpoint of filteredEndpoints.value) {
      // Determine group key
      let groupKey: string;

      if (endpoint.tags.length > 0) {
        // Use first tag as group
        groupKey = endpoint.tags[0];
      } else if (endpoint.responseSchema) {
        // Fallback to response schema
        groupKey = endpoint.responseSchema;
      } else {
        // Final fallback: first path segment
        const segments = endpoint.path.split('/').filter(Boolean);
        groupKey = segments[0] || 'Other';
      }

      if (!groups.has(groupKey)) {
        groups.set(groupKey, []);
      }
      groups.get(groupKey)?.push(endpoint);
    }

    // Convert to array and sort
    return Array.from(groups.entries())
      .map(([tag, eps]) => ({
        tag,
        endpoints: eps.sort((a, b) => a.path.localeCompare(b.path)),
        isExpanded: expandedTags.value.has(tag),
      }))
      .sort((a, b) => a.tag.localeCompare(b.tag));
  });

  /**
   * Currently selected endpoint
   */
  const selectedEndpoint = computed(() => {
    if (!selectedEndpointKey.value) return null;
    return endpoints.value.find((e) => e.key === selectedEndpointKey.value) ?? null;
  });

  /**
   * Count of endpoints with custom handlers
   */
  const handlerCount = computed(() => endpoints.value.filter((e) => e.hasHandler).length);

  /**
   * Count of endpoints with seed data
   */
  const seedCount = computed(() => endpoints.value.filter((e) => e.hasSeed).length);

  // ==========================================================================
  // Actions
  // ==========================================================================

  /**
   * Set registry data from server response
   */
  function setRegistryData(data: RegistryData): void {
    endpoints.value = data.endpoints;
    stats.value = data.stats;
    error.value = null;

    // Auto-expand all groups initially
    for (const endpoint of data.endpoints) {
      if (endpoint.tags.length > 0) {
        expandedTags.value.add(endpoint.tags[0]);
      }
    }
  }

  /**
   * Set loading state
   */
  function setLoading(loading: boolean): void {
    isLoading.value = loading;
  }

  /**
   * Set error state
   */
  function setError(errorMessage: string): void {
    error.value = errorMessage;
    isLoading.value = false;
  }

  /**
   * Clear error state
   */
  function clearError(): void {
    error.value = null;
  }

  /**
   * Set search query
   */
  function setSearchQuery(query: string): void {
    searchQuery.value = query;
  }

  /**
   * Toggle method filter
   */
  function toggleMethodFilter(method: HttpMethod): void {
    const index = filter.value.methods.indexOf(method);
    if (index === -1) {
      filter.value.methods.push(method);
    } else {
      filter.value.methods.splice(index, 1);
    }
  }

  /**
   * Set handler filter
   */
  function setHandlerFilter(hasHandler: boolean | null): void {
    filter.value.hasHandler = hasHandler;
  }

  /**
   * Set seed filter
   */
  function setSeedFilter(hasSeed: boolean | null): void {
    filter.value.hasSeed = hasSeed;
  }

  /**
   * Toggle tag filter
   */
  function toggleTagFilter(tag: string): void {
    const index = filter.value.tags.indexOf(tag);
    if (index === -1) {
      filter.value.tags.push(tag);
    } else {
      filter.value.tags.splice(index, 1);
    }
  }

  /**
   * Clear all filters
   */
  function clearFilters(): void {
    filter.value = {
      methods: [],
      hasHandler: null,
      hasSeed: null,
      tags: [],
    };
    searchQuery.value = '';
  }

  /**
   * Check if any filter is active
   */
  function hasActiveFilters(): boolean {
    return (
      searchQuery.value.trim() !== '' ||
      filter.value.methods.length > 0 ||
      filter.value.hasHandler !== null ||
      filter.value.hasSeed !== null ||
      filter.value.tags.length > 0
    );
  }

  /**
   * Select an endpoint by key
   */
  function selectEndpoint(key: string | null): void {
    selectedEndpointKey.value = key;
  }

  /**
   * Toggle group expansion
   */
  function toggleGroup(tag: string): void {
    if (expandedTags.value.has(tag)) {
      expandedTags.value.delete(tag);
    } else {
      expandedTags.value.add(tag);
    }
  }

  /**
   * Expand all groups
   */
  function expandAllGroups(): void {
    for (const group of groupedEndpoints.value) {
      expandedTags.value.add(group.tag);
    }
  }

  /**
   * Collapse all groups
   */
  function collapseAllGroups(): void {
    expandedTags.value.clear();
  }

  /**
   * Update handler status for endpoints
   * Called when handlers are reloaded
   */
  function updateHandlerStatus(handlerOperationIds: string[]): void {
    const handlerSet = new Set(handlerOperationIds);
    for (const endpoint of endpoints.value) {
      endpoint.hasHandler = handlerSet.has(endpoint.operationId);
    }
  }

  /**
   * Update seed status for endpoints
   * Called when seeds are reloaded
   */
  function updateSeedStatus(seedSchemas: string[]): void {
    const seedSet = new Set(seedSchemas);
    for (const endpoint of endpoints.value) {
      endpoint.hasSeed = endpoint.responseSchema ? seedSet.has(endpoint.responseSchema) : false;
    }
  }

  // ==========================================================================
  // Return
  // ==========================================================================

  return {
    // State
    endpoints,
    stats,
    isLoading,
    error,
    searchQuery,
    filter,
    selectedEndpointKey,
    expandedTags,

    // Getters
    allTags,
    allSchemas,
    filteredEndpoints,
    groupedEndpoints,
    selectedEndpoint,
    handlerCount,
    seedCount,

    // Actions
    setRegistryData,
    setLoading,
    setError,
    clearError,
    setSearchQuery,
    toggleMethodFilter,
    setHandlerFilter,
    setSeedFilter,
    toggleTagFilter,
    clearFilters,
    hasActiveFilters,
    selectEndpoint,
    toggleGroup,
    expandAllGroups,
    collapseAllGroups,
    updateHandlerStatus,
    updateSeedStatus,
  };
});
