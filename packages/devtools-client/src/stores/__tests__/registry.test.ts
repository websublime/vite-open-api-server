/**
 * Registry Store Tests
 *
 * What: Unit tests for the registry Pinia store
 * How: Tests state management, computed properties, and actions
 * Why: Ensures reliable endpoint registry functionality for the Routes Page
 *
 * @module stores/__tests__/registry.test
 */

import { createPinia, setActivePinia } from 'pinia';
import { beforeEach, describe, expect, it } from 'vitest';

import {
  type EndpointEntry,
  type RegistryData,
  type RegistryStats,
  useRegistryStore,
} from '../registry';

/**
 * Create mock endpoint entry
 */
function createMockEndpoint(overrides: Partial<EndpointEntry> = {}): EndpointEntry {
  return {
    key: 'get:/pets',
    operationId: 'listPets',
    method: 'get',
    path: '/pets',
    summary: 'List all pets',
    description: 'Returns all pets from the store',
    tags: ['pet'],
    responseSchema: 'Pet',
    hasHandler: false,
    hasSeed: false,
    security: [],
    ...overrides,
  };
}

/**
 * Create mock registry data
 */
function createMockRegistryData(endpoints: EndpointEntry[] = []): RegistryData {
  const stats: RegistryStats = {
    totalEndpoints: endpoints.length,
    withCustomHandler: endpoints.filter((e) => e.hasHandler).length,
    totalSchemas: new Set(endpoints.map((e) => e.responseSchema).filter(Boolean)).size,
    withCustomSeed: endpoints.filter((e) => e.hasSeed).length,
    autoGenerated: endpoints.filter((e) => !e.hasHandler && !e.hasSeed).length,
  };

  return { endpoints, stats };
}

describe('useRegistryStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  describe('initial state', () => {
    it('should have empty endpoints array', () => {
      const store = useRegistryStore();
      expect(store.endpoints).toEqual([]);
    });

    it('should have default stats', () => {
      const store = useRegistryStore();
      expect(store.stats).toEqual({
        totalEndpoints: 0,
        withCustomHandler: 0,
        totalSchemas: 0,
        withCustomSeed: 0,
        autoGenerated: 0,
      });
    });

    it('should not be loading', () => {
      const store = useRegistryStore();
      expect(store.isLoading).toBe(false);
    });

    it('should have no error', () => {
      const store = useRegistryStore();
      expect(store.error).toBeNull();
    });

    it('should have empty search query', () => {
      const store = useRegistryStore();
      expect(store.searchQuery).toBe('');
    });

    it('should have no selected endpoint', () => {
      const store = useRegistryStore();
      expect(store.selectedEndpointKey).toBeNull();
    });
  });

  describe('setRegistryData', () => {
    it('should set endpoints from data', () => {
      const store = useRegistryStore();
      const endpoint = createMockEndpoint();
      const data = createMockRegistryData([endpoint]);

      store.setRegistryData(data);

      expect(store.endpoints).toHaveLength(1);
      expect(store.endpoints[0]).toEqual(endpoint);
    });

    it('should set stats from data', () => {
      const store = useRegistryStore();
      const endpoints = [
        createMockEndpoint({ hasHandler: true }),
        createMockEndpoint({ key: 'post:/pets', method: 'post', operationId: 'createPet' }),
      ];
      const data = createMockRegistryData(endpoints);

      store.setRegistryData(data);

      expect(store.stats.totalEndpoints).toBe(2);
      expect(store.stats.withCustomHandler).toBe(1);
    });

    it('should clear error on set', () => {
      const store = useRegistryStore();
      store.setError('Previous error');

      store.setRegistryData(createMockRegistryData([]));

      expect(store.error).toBeNull();
    });

    it('should auto-expand tag groups', () => {
      const store = useRegistryStore();
      const endpoint = createMockEndpoint({ tags: ['pet'] });
      const data = createMockRegistryData([endpoint]);

      store.setRegistryData(data);

      expect(store.expandedTags.has('pet')).toBe(true);
    });
  });

  describe('loading state', () => {
    it('should set loading to true', () => {
      const store = useRegistryStore();
      store.setLoading(true);
      expect(store.isLoading).toBe(true);
    });

    it('should set loading to false', () => {
      const store = useRegistryStore();
      store.setLoading(true);
      store.setLoading(false);
      expect(store.isLoading).toBe(false);
    });
  });

  describe('error state', () => {
    it('should set error message', () => {
      const store = useRegistryStore();
      store.setError('Failed to fetch');
      expect(store.error).toBe('Failed to fetch');
    });

    it('should clear loading when error is set', () => {
      const store = useRegistryStore();
      store.setLoading(true);
      store.setError('Error');
      expect(store.isLoading).toBe(false);
    });

    it('should clear error', () => {
      const store = useRegistryStore();
      store.setError('Error');
      store.clearError();
      expect(store.error).toBeNull();
    });
  });

  describe('search functionality', () => {
    it('should set search query', () => {
      const store = useRegistryStore();
      store.setSearchQuery('pet');
      expect(store.searchQuery).toBe('pet');
    });

    it('should filter endpoints by path', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ key: 'get:/pets', path: '/pets' }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            summary: 'Get users',
            description: 'Returns all users',
            tags: ['user'],
            responseSchema: 'User',
          }),
        ]),
      );

      store.setSearchQuery('pet');

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].path).toBe('/pets');
    });

    it('should filter endpoints by operationId', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ operationId: 'listPets' }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            tags: ['user'],
          }),
        ]),
      );

      store.setSearchQuery('listUsers');

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].operationId).toBe('listUsers');
    });

    it('should filter endpoints by summary', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ summary: 'List all pets' }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            summary: 'Get users',
            tags: ['user'],
          }),
        ]),
      );

      store.setSearchQuery('users');

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].summary).toBe('Get users');
    });

    it('should filter endpoints by tags', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: ['pet'] }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            tags: ['admin'],
          }),
        ]),
      );

      store.setSearchQuery('admin');

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].tags).toContain('admin');
    });

    it('should be case insensitive', () => {
      const store = useRegistryStore();
      store.setRegistryData(createMockRegistryData([createMockEndpoint({ path: '/PETS' })]));

      store.setSearchQuery('pets');

      expect(store.filteredEndpoints).toHaveLength(1);
    });
  });

  describe('method filter', () => {
    it('should toggle method filter on', () => {
      const store = useRegistryStore();
      store.toggleMethodFilter('get');
      expect(store.filter.methods).toContain('get');
    });

    it('should toggle method filter off', () => {
      const store = useRegistryStore();
      store.toggleMethodFilter('get');
      store.toggleMethodFilter('get');
      expect(store.filter.methods).not.toContain('get');
    });

    it('should filter endpoints by method', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ method: 'get' }),
          createMockEndpoint({ key: 'post:/pets', method: 'post', operationId: 'createPet' }),
        ]),
      );

      store.toggleMethodFilter('post');

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].method).toBe('post');
    });

    it('should allow multiple method filters', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ method: 'get' }),
          createMockEndpoint({ key: 'post:/pets', method: 'post', operationId: 'createPet' }),
          createMockEndpoint({ key: 'delete:/pets', method: 'delete', operationId: 'deletePet' }),
        ]),
      );

      store.toggleMethodFilter('get');
      store.toggleMethodFilter('post');

      expect(store.filteredEndpoints).toHaveLength(2);
    });
  });

  describe('handler/seed filters', () => {
    it('should set handler filter', () => {
      const store = useRegistryStore();
      store.setHandlerFilter(true);
      expect(store.filter.hasHandler).toBe(true);
    });

    it('should clear handler filter', () => {
      const store = useRegistryStore();
      store.setHandlerFilter(true);
      store.setHandlerFilter(null);
      expect(store.filter.hasHandler).toBeNull();
    });

    it('should filter endpoints by handler', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ hasHandler: true }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            hasHandler: false,
          }),
        ]),
      );

      store.setHandlerFilter(true);

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].hasHandler).toBe(true);
    });

    it('should set seed filter', () => {
      const store = useRegistryStore();
      store.setSeedFilter(true);
      expect(store.filter.hasSeed).toBe(true);
    });

    it('should filter endpoints by seed', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ hasSeed: true }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            hasSeed: false,
          }),
        ]),
      );

      store.setSeedFilter(true);

      expect(store.filteredEndpoints).toHaveLength(1);
      expect(store.filteredEndpoints[0].hasSeed).toBe(true);
    });
  });

  describe('clearFilters', () => {
    it('should clear all filters', () => {
      const store = useRegistryStore();
      store.setSearchQuery('test');
      store.toggleMethodFilter('get');
      store.setHandlerFilter(true);
      store.setSeedFilter(true);

      // Verify filters are set
      expect(store.searchQuery).toBe('test');
      expect(store.filter.methods).toContain('get');
      expect(store.filter.hasHandler).toBe(true);
      expect(store.filter.hasSeed).toBe(true);

      store.clearFilters();

      expect(store.searchQuery).toBe('');
      expect(store.filter.methods).toEqual([]);
      expect(store.filter.hasHandler).toBeNull();
      expect(store.filter.hasSeed).toBeNull();
    });
  });

  describe('hasActiveFilters', () => {
    it('should return false when no filters active', () => {
      const store = useRegistryStore();
      expect(store.hasActiveFilters()).toBe(false);
    });

    it('should return true when search is active', () => {
      const store = useRegistryStore();
      store.setSearchQuery('test');
      expect(store.hasActiveFilters()).toBe(true);
    });

    it('should return true when method filter is active', () => {
      const store = useRegistryStore();
      store.toggleMethodFilter('get');
      // Verify the method was added
      expect(store.filter.methods).toContain('get');
      expect(store.hasActiveFilters()).toBe(true);
    });

    it('should return true when handler filter is active', () => {
      const store = useRegistryStore();
      store.setHandlerFilter(true);
      // Verify the filter was set
      expect(store.filter.hasHandler).toBe(true);
      expect(store.hasActiveFilters()).toBe(true);
    });
  });

  describe('endpoint selection', () => {
    it('should select endpoint by key', () => {
      const store = useRegistryStore();
      store.setRegistryData(createMockRegistryData([createMockEndpoint({ key: 'get:/pets' })]));

      store.selectEndpoint('get:/pets');

      expect(store.selectedEndpointKey).toBe('get:/pets');
    });

    it('should return selected endpoint', () => {
      const store = useRegistryStore();
      const endpoint = createMockEndpoint({ key: 'get:/pets' });
      store.setRegistryData(createMockRegistryData([endpoint]));

      store.selectEndpoint('get:/pets');

      expect(store.selectedEndpoint).toEqual(endpoint);
    });

    it('should return null when no endpoint selected', () => {
      const store = useRegistryStore();
      expect(store.selectedEndpoint).toBeNull();
    });

    it('should return null when selected key not found', () => {
      const store = useRegistryStore();
      store.selectEndpoint('nonexistent');
      expect(store.selectedEndpoint).toBeNull();
    });

    it('should deselect endpoint', () => {
      const store = useRegistryStore();
      store.selectEndpoint('get:/pets');
      store.selectEndpoint(null);
      expect(store.selectedEndpointKey).toBeNull();
    });
  });

  describe('group expansion', () => {
    it('should toggle group expansion on', () => {
      const store = useRegistryStore();
      store.toggleGroup('pet');
      expect(store.expandedTags.has('pet')).toBe(true);
    });

    it('should toggle group expansion off', () => {
      const store = useRegistryStore();
      store.toggleGroup('pet');
      store.toggleGroup('pet');
      expect(store.expandedTags.has('pet')).toBe(false);
    });

    it('should expand all groups', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: ['pet'] }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            tags: ['user'],
          }),
        ]),
      );

      // First collapse all
      store.collapseAllGroups();
      expect(store.expandedTags.size).toBe(0);

      // Then expand all
      store.expandAllGroups();
      expect(store.expandedTags.has('pet')).toBe(true);
      expect(store.expandedTags.has('user')).toBe(true);
    });

    it('should collapse all groups', () => {
      const store = useRegistryStore();
      store.toggleGroup('pet');
      store.toggleGroup('user');

      store.collapseAllGroups();

      expect(store.expandedTags.size).toBe(0);
    });
  });

  describe('groupedEndpoints', () => {
    it('should group endpoints by first tag', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: ['pet'] }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            tags: ['pet'],
          }),
        ]),
      );

      const groups = store.groupedEndpoints;

      expect(groups).toHaveLength(1);
      expect(groups[0].tag).toBe('pet');
      expect(groups[0].endpoints).toHaveLength(2);
    });

    it('should group by response schema when no tags', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: [], responseSchema: 'Pet' }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            tags: [],
            responseSchema: 'Pet',
          }),
        ]),
      );

      const groups = store.groupedEndpoints;

      expect(groups).toHaveLength(1);
      expect(groups[0].tag).toBe('Pet');
    });

    it('should group by path segment when no tags or schema', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({
            path: '/pets',
            tags: [],
            responseSchema: undefined,
          }),
        ]),
      );

      const groups = store.groupedEndpoints;

      expect(groups).toHaveLength(1);
      expect(groups[0].tag).toBe('pets');
    });

    it('should sort groups alphabetically', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: ['zebra'] }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            tags: ['apple'],
          }),
        ]),
      );

      const groups = store.groupedEndpoints;

      expect(groups[0].tag).toBe('apple');
      expect(groups[1].tag).toBe('zebra');
    });

    it('should sort endpoints within groups by path', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ path: '/pets/{petId}', tags: ['pet'] }),
          createMockEndpoint({
            key: 'get:/pets',
            path: '/pets',
            operationId: 'listPets',
            tags: ['pet'],
          }),
        ]),
      );

      const groups = store.groupedEndpoints;

      expect(groups[0].endpoints[0].path).toBe('/pets');
      expect(groups[0].endpoints[1].path).toBe('/pets/{petId}');
    });

    it('should include expansion state', () => {
      const store = useRegistryStore();
      store.setRegistryData(createMockRegistryData([createMockEndpoint({ tags: ['pet'] })]));

      // setRegistryData auto-expands groups, so first verify it's expanded
      expect(store.groupedEndpoints[0].isExpanded).toBe(true);

      // Toggle to collapse
      store.toggleGroup('pet');
      expect(store.groupedEndpoints[0].isExpanded).toBe(false);

      // Toggle again to expand
      store.toggleGroup('pet');
      expect(store.groupedEndpoints[0].isExpanded).toBe(true);
    });
  });

  describe('computed counts', () => {
    it('should count all tags', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ tags: ['pet', 'store'] }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            tags: ['user'],
          }),
        ]),
      );

      expect(store.allTags).toEqual(['pet', 'store', 'user']);
    });

    it('should count all schemas', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ responseSchema: 'Pet' }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            responseSchema: 'User',
            tags: ['user'],
          }),
        ]),
      );

      expect(store.allSchemas).toEqual(['Pet', 'User']);
    });

    it('should count handlers', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ hasHandler: true }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            hasHandler: true,
          }),
          createMockEndpoint({
            key: 'delete:/pets',
            method: 'delete',
            operationId: 'deletePet',
            hasHandler: false,
          }),
        ]),
      );

      expect(store.handlerCount).toBe(2);
    });

    it('should count seeds', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ hasSeed: true }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            hasSeed: false,
          }),
        ]),
      );

      expect(store.seedCount).toBe(1);
    });
  });

  describe('updateHandlerStatus', () => {
    it('should update handler status for matching operationIds', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ operationId: 'listPets', hasHandler: false }),
          createMockEndpoint({
            key: 'post:/pets',
            method: 'post',
            operationId: 'createPet',
            hasHandler: false,
          }),
        ]),
      );

      store.updateHandlerStatus(['listPets']);

      expect(store.endpoints[0].hasHandler).toBe(true);
      expect(store.endpoints[1].hasHandler).toBe(false);
    });
  });

  describe('updateSeedStatus', () => {
    it('should update seed status for matching schemas', () => {
      const store = useRegistryStore();
      store.setRegistryData(
        createMockRegistryData([
          createMockEndpoint({ responseSchema: 'Pet', hasSeed: false }),
          createMockEndpoint({
            key: 'get:/users',
            path: '/users',
            operationId: 'listUsers',
            responseSchema: 'User',
            hasSeed: false,
            tags: ['user'],
          }),
        ]),
      );

      store.updateSeedStatus(['Pet']);

      expect(store.endpoints[0].hasSeed).toBe(true);
      expect(store.endpoints[1].hasSeed).toBe(false);
    });
  });
});
